<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>数据集序列编码生成器 (最终版)</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: #f4f7f9;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 20px;
            min-height: 100vh;
        }
        .container {
            background-color: #fff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            width: 1200px;
        }
        h1 {
            text-align: center;
            color: #2c3e50;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 10px;
            margin-top: 0;
        }
        .main-content {
            display: flex;
            gap: 30px;
        }
        .config-panel {
            flex: 1.2;
        }
        .vis-panel {
            flex: 1;
            min-width: 0;
        }
        h2 {
            text-align: center;
            color: #2c3e50;
            border-bottom: 1px solid #e9e9e9;
            padding-bottom: 10px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        th, td {
            padding: 12px;
            text-align: center;
            border: 1px solid #ddd;
        }
        th {
            background-color: #f8f9fa;
            font-weight: 600;
        }
        select, button {
            width: 100%;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #ccc;
            font-size: 16px;
            box-sizing: border-box;
        }
        select option:disabled {
            color: #ccc;
            background-color: #f9f9f9;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2980b9;
        }
        .result-container {
            margin-top: 40px;
            padding: 10px 15px;
            background-color: #ecf0f1;
            border: 1px solid #bdc3c7;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 15px;
        }
        #result-code {
            font-family: "Courier New", Courier, monospace;
            font-size: 1.2em;
            font-weight: bold;
            color: #2c3e50;
            word-break: break-all;
            flex-grow: 1;
            text-align: left;
        }
        .error-message {
            color: #e74c3c;
            font-weight: bold;
            text-align: center;
            margin-top: 20px;
            height: 20px;
        }
        #copyBtn {
            width: auto;
            padding: 8px 12px;
            background-color: #7f8c8d;
            flex-shrink: 0;
            border: none;
            cursor: pointer;
            border-radius: 4px;
            color: white;
        }
        #copyBtn:hover {
            background-color: #95a5a6;
        }
        #copyBtn.copied {
            background-color: #27ae60;
        }
        #copyBtn svg {
            width: 16px;
            height: 16px;
            vertical-align: middle;
        }
        #vis-container {
            width: 100%;
            height: 0;
            padding-bottom: 100%;
            position: relative;
            background-color: #eaf2f8;
            border-radius: 8px;
        }
        #scene-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
            }
        }
    </script>
</head>
<body>

<div class="container">
    <h1>数据集序列编码生成器</h1>
    <div class="main-content">
        <div class="config-panel">
            <div class="section">
                <h2>场景规格 (SceneSpec)</h2>
                <table>
                    <thead>
                        <tr>
                            <th>属性</th>
                            <th>物体 1</th>
                            <th>物体 2</th>
                            <th>物体 3</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><b>门类型 (DoorType)</b></td>
                            <td><select id="door1"></select></td>
                            <td><select id="door2"></select></td>
                            <td><select id="door3"></select></td>
                        </tr>
                        <tr>
                            <td><b>位置 (Pos)</b></td>
                            <td><select id="pos1"></select></td>
                            <td><select id="pos2"></select></td>
                            <td><select id="pos3"></select></td>
                        </tr>
                        <tr>
                            <td><b>开门方向 (OpenDir)</b></td>
                            <td><select id="dir1"></select></td>
                            <td><select id="dir2"></select></td>
                            <td><select id="dir3"></select></td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="section">
                <h2>交互规格 (InteractionSpec)</h2>
                <table>
                    <thead>
                        <tr>
                            <th>交互模式 (Mode)</th>
                            <th>SMPL 高度 (Height)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><select id="mode"></select></td>
                            <td><select id="height"></select></td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="error-message" id="error-message"></div>
            <div class="result-container">
                <span id="result-code">L_hm00f_nm20f_bh01u_M0H0</span>
                <button id="copyBtn" title="复制编码">
                    <svg id="copy-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
                    <svg id="check-icon" style="display: none;" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>
                </button>
            </div>
        </div>
        <div class="vis-panel">
            <h2>场景实时预览</h2>
            <div id="vis-container">
                <canvas id="scene-canvas"></canvas>
            </div>
        </div>
    </div>
</div>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // --- 数据定义 ---
    const ALL_POSITIONS = Array.from({length: 3}, (_, z) => Array.from({length: 3}, (_, x) => `${x}${z}`)).flat();
    const DOOR_TYPES = {
        'hm': '河马口 (hm)', 'nm': '普通口 (nm)', 'bh': '长条口-横 (bh)',
        'bv': '长条口-竖 (bv)', 'dl': '双开左 (dl)', 'dr': '双开右 (dr)',
        'dlb': '双开全 (dlb)'
    };
    const OPEN_DIRS = {'f': '前 (f)', 'u': '上 (u)', 'l': '左 (l)', 'r': '右 (r)'};
    const MODES = {'M0': '左-右-左 (M0)', 'M1': '右-左-右 (M1)', 'M2': '双手+单手 (M2)'};
    const HEIGHTS = {'H0': '地面高度 (H0)', 'H2': '胸部高度 (H2)'};

    // --- 页面初始化 ---
    function populateSelect(selectId, options, defaultKey) {
        const select = document.getElementById(selectId);
        select.innerHTML = '';
        for (const key in options) {
            const option = new Option(options[key], key);
            select.add(option);
        }
        if (defaultKey) select.value = defaultKey;
    }

    function initialize() {
        for (let i = 1; i <= 3; i++) {
            populateSelect(`door${i}`, DOOR_TYPES);
            populateSelect(`pos${i}`, Object.fromEntries(ALL_POSITIONS.map(p => [p, p])));
            populateSelect(`dir${i}`, OPEN_DIRS);
            ['door', 'pos', 'dir'].forEach(type => {
                document.getElementById(`${type}${i}`).addEventListener('change', updateUIAndValidation);
            });
        }
        ['mode', 'height'].forEach(type => {
             document.getElementById(type).addEventListener('change', updateUIAndValidation);
        });

        document.getElementById('door1').value = 'hm';
        document.getElementById('pos1').value = '00';
        document.getElementById('door2').value = 'nm';
        document.getElementById('pos2').value = '20';
        document.getElementById('door3').value = 'bh';
        document.getElementById('pos3').value = '01';
        
        populateSelect('mode', MODES, 'M0');
        populateSelect('height', HEIGHTS, 'H0');
    }

    // --- 核心校验与UI更新逻辑 ---
    const errorMessage = document.getElementById('error-message');
    const resultCodeEl = document.getElementById('result-code');

    function getFootprint(pos, doorType) {
        const x = parseInt(pos[0]);
        const z = parseInt(pos[1]);
        const footprint = [pos];
        if (['bh', 'dl', 'dr', 'dlb'].includes(doorType)) footprint.push(`${x + 1}${z}`);
        else if (doorType === 'bv') footprint.push(`${x}${z + 1}`);
        return footprint;
    }

    function checkBounds(pos, doorType) {
        const x = parseInt(pos[0]);
        const z = parseInt(pos[1]);
        if ((['bh', 'dl', 'dr', 'dlb'].includes(doorType) && x > 1) || (doorType === 'bv' && z > 1)) {
            return false;
        }
        return true;
    }

    function updateUIAndValidation() {
        errorMessage.textContent = '';
        let isConfigurationValid = true;

        const state = [];
        for (let i = 1; i <= 3; i++) {
            state.push({
                id: i,
                door: document.getElementById(`door${i}`).value,
                pos: document.getElementById(`pos${i}`).value,
                dir: document.getElementById(`dir${i}`).value,
            });
        }
        const currentMode = document.getElementById('mode').value;
        const isM2Selected = currentMode === 'M2';
        const isDlbSelectedByAny = state.some(s => s.door === 'dlb');

        for (let i = 0; i < 3; i++) {
            const self = state[i];
            const others = state.filter(s => s.id !== self.id);
            const otherDoors = others.map(o => o.door);
            const otherFootprints = others.flatMap(o => getFootprint(o.pos, o.door));

            const doorSelect = document.getElementById(`door${i + 1}`);
            Array.from(doorSelect.options).forEach(opt => {
                let isDisabled = otherDoors.includes(opt.value);
                if (opt.value === 'dlb' && !isM2Selected) {
                    isDisabled = true;
                }
                opt.disabled = isDisabled;
            });

            const posSelect = document.getElementById(`pos${i + 1}`);
            Array.from(posSelect.options).forEach(opt => {
                const pos = opt.value;
                const isOutOfBounds = !checkBounds(pos, self.door);
                const selfFootprint = getFootprint(pos, self.door);
                const isColliding = selfFootprint.some(cell => otherFootprints.includes(cell));
                opt.disabled = isOutOfBounds || isColliding;
            });

            const dirSelect = document.getElementById(`dir${i + 1}`);
            Array.from(dirSelect.options).forEach(opt => {
                const dir = opt.value;
                const x = parseInt(self.pos[0]);
                const z = parseInt(self.pos[1]);
                let targetPos = '';
                if (dir === 'u') targetPos = `${x}${z + 1}`;
                else if (dir === 'l') targetPos = `${x - 1}${z}`;
                else if (dir === 'r') targetPos = `${x + 1}${z}`;
                
                const isBlockedByOther = targetPos && otherFootprints.includes(targetPos);
                const isInvalidForDoubleDoor = (['dl', 'dr', 'dlb'].includes(self.door)) && (dir === 'l' || dir === 'r');
                const isInvalidForBarHorizontal = (self.door === 'bh') && (dir === 'l' || dir === 'r');
                const isInvalidForBarVertical = (self.door === 'bv') && (dir === 'u');
                
                opt.disabled = isBlockedByOther || isInvalidForDoubleDoor || isInvalidForBarHorizontal || isInvalidForBarVertical;
            });
        }

        const modeSelect = document.getElementById('mode');
        Array.from(modeSelect.options).forEach(opt => {
            opt.disabled = isDlbSelectedByAny && opt.value !== 'M2';
        });

        for (let i = 1; i <= 3; i++) {
            if (document.getElementById(`door${i}`).selectedOptions[0].disabled ||
                document.getElementById(`pos${i}`).selectedOptions[0].disabled ||
                document.getElementById(`dir${i}`).selectedOptions[0].disabled) {
                isConfigurationValid = false;
                errorMessage.textContent = '当前配置无效，请调整选项。';
            }
        }
        if (document.getElementById('mode').selectedOptions[0].disabled) {
            isConfigurationValid = false;
            errorMessage.textContent = '当前配置无效，请调整选项。';
        }

        updateVisualization();
        generateCode(isConfigurationValid);
    }

    // --- 编码生成 ---
    function generateCode(isValid) {
        if (!isValid) {
            resultCodeEl.textContent = '---';
            return;
        }

        const objects = [];
        for (let i = 1; i <= 3; i++) {
            objects.push({
                door: document.getElementById(`door${i}`).value,
                pos: document.getElementById(`pos${i}`).value,
                dir: document.getElementById(`dir${i}`).value,
            });
        }
        const mode = document.getElementById('mode').value;
        const height = document.getElementById('height').value;
        const seqType = 'L';
        const sceneSpec = objects.map(o => `${o.door}${o.pos}${o.dir}`).join('_');
        const interactionSpec = `${mode}${height}`;
        const finalCode = `${seqType}_${sceneSpec}_${interactionSpec}`;
        resultCodeEl.textContent = finalCode;
    }

    // --- 复制按钮逻辑 ---
    const copyBtn = document.getElementById('copyBtn');
    copyBtn.addEventListener('click', () => {
        const textToCopy = resultCodeEl.textContent;
        if (textToCopy === '---') return;
        navigator.clipboard.writeText(textToCopy).then(() => {
            // ... (复制反馈逻辑不变)
        });
    });

    // --- Three.js 可视化逻辑 ---
    let scene, camera, renderer, controls, gridGroup;
    const CUBE_SIZE = 0.8;
    const GRID_SPACING = 0.85;
    const GAP = GRID_SPACING - CUBE_SIZE;

    function initThree() {
        const canvas = document.getElementById('scene-canvas');
        const container = document.getElementById('vis-container');
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xeaf2f8);
        camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 100);
        camera.position.set(3, 4, 5);
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);
        renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, GRID_SPACING, 0);
        gridGroup = new THREE.Group();
        scene.add(gridGroup);
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
        window.addEventListener('resize', () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });
    }

    function updateVisualization() {
        if (!gridGroup) return;
        gridGroup.clear();

        const selectedObjects = [];
        for (let i = 1; i <= 3; i++) {
            selectedObjects.push({
                pos: document.getElementById(`pos${i}`).value,
                door: document.getElementById(`door${i}`).value,
                dir: document.getElementById(`dir${i}`).value
            });
        }

        const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x3498db, roughness: 0.4 });
        const doorMaterial = new THREE.MeshStandardMaterial({ color: 0xe74c3c, roughness: 0.4 });
        const placeholderMaterial = new THREE.MeshStandardMaterial({ color: 0xbdc3c7, transparent: true, opacity: 0.3 });
        
        const occupiedCells = new Set(selectedObjects.flatMap(obj => getFootprint(obj.pos, obj.door)));

        selectedObjects.forEach(obj => {
            const x = parseInt(obj.pos[0]);
            const z = parseInt(obj.pos[1]);
            let geometry, mesh;
            let posX = (x - 1) * GRID_SPACING;
            let posY = z * GRID_SPACING;
            
            if (['bh', 'dl', 'dr', 'dlb'].includes(obj.door)) {
                geometry = new THREE.BoxGeometry(CUBE_SIZE * 2 + GAP, CUBE_SIZE, CUBE_SIZE);
                posX += GRID_SPACING / 2;
            } else if (obj.door === 'bv') {
                geometry = new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE * 2 + GAP, CUBE_SIZE);
                posY += GRID_SPACING / 2;
            } else {
                geometry = new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE);
            }

            const materials = Array(6).fill(baseMaterial);
            const dirMap = { 'r': 0, 'l': 1, 'u': 2, 'f': 4 };
            
            if (dirMap[obj.dir] !== undefined) {
                materials[dirMap[obj.dir]] = doorMaterial;
            }
            
            mesh = new THREE.Mesh(geometry, materials);
            mesh.position.set(posX, posY, 0);
            gridGroup.add(mesh);

            // 为 dl/dr 单独添加蓝色半面，覆盖掉整面红色
            if (['dl', 'dr'].includes(obj.door)) {
                if (obj.dir === 'f') {
                    const halfDoorGeo = new THREE.PlaneGeometry(CUBE_SIZE, CUBE_SIZE);
                    const halfDoorMesh = new THREE.Mesh(halfDoorGeo, baseMaterial); // 先用蓝色覆盖
                    halfDoorMesh.position.z = CUBE_SIZE / 2 + 0.001;
                    halfDoorMesh.position.x = (obj.door === 'dl') ? CUBE_SIZE / 2 : -CUBE_SIZE / 2; // 覆盖另一半
                    mesh.add(halfDoorMesh);
                } else if (obj.dir === 'u') {
                    const halfDoorGeo = new THREE.PlaneGeometry(CUBE_SIZE, CUBE_SIZE);
                    const halfDoorMesh = new THREE.Mesh(halfDoorGeo, baseMaterial); // 先用蓝色覆盖
                    halfDoorMesh.rotation.x = -Math.PI / 2;
                    halfDoorMesh.position.y = CUBE_SIZE / 2 + 0.001;
                    halfDoorMesh.position.x = (obj.door === 'dl') ? CUBE_SIZE / 2 : -CUBE_SIZE / 2; // 覆盖另一半
                    mesh.add(halfDoorMesh);
                }
            }
        });

        const placeholderGeo = new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE);
        for (let z = 0; z < 3; z++) {
            for (let x = 0; x < 3; x++) {
                if (!occupiedCells.has(`${x}${z}`)) {
                    const placeholder = new THREE.Mesh(placeholderGeo, placeholderMaterial);
                    placeholder.position.set((x - 1) * GRID_SPACING, z * GRID_SPACING, 0);
                    gridGroup.add(placeholder);
                }
            }
        }

        const planeGeo = new THREE.PlaneGeometry(GRID_SPACING * 3, GRID_SPACING * 3);
        const planeMat = new THREE.MeshStandardMaterial({color: 0xffffff, side: THREE.DoubleSide});
        const plane = new THREE.Mesh(planeGeo, planeMat);
        plane.rotation.x = -Math.PI / 2;
        plane.position.y = -CUBE_SIZE / 2;
        gridGroup.add(plane);
    }

    initialize();
    initThree();
    updateUIAndValidation();

</script>
</body>
</html>
